<!-- $Id: sqltool.xml,v 1.17 2004/06/06 04:35:10 unsaved Exp $ -->

<chapter id='sqltool-chapter'>
    <title id='sqltool-title'>SqlTool</title>
    <subtitle>SqlTool Manual and HOWTO</subtitle>
    <chapterinfo>
        <author>
            <firstname>Blaine</firstname><surname>Simpson</surname>
            <email>&blaineaddr;</email>
            <affiliation>
                <orgname>HSQLDB Development Group</orgname>
            </affiliation>
        </author>
        <edition>$Revision: 1.17 $</edition>
        <pubdate>$Date: 2004/06/06 04:35:10 $</pubdate>
        <keywordset>
            <keyword>HSQLDB</keyword>
            <keyword>HOWTO</keyword>
            <keyword>SQL</keyword>
            <keyword>JDBC</keyword>
        </keywordset>
    </chapterinfo>

    <section>
        <title>Purpose</title>
        <simpara>
            This document explains how to use SqlTool, the main purpose of
            which is to read your SQL text file or stdin, and execute the SQL 
            commands therein against a JDBC database.
            There are also many features to both facilite interactive 
            (such as command-line editing and aliases), and to facilitate
            automation (such as file inclusion and scripting variables).
        </simpara><simpara>
            Some of the examples below use quoting which works exactly
            as-is for any normal UNIX shell.
            I have not yet tested these commands on Windows, and I doubt
            whether the quoting will work just like this (though it is
            possible).
        </simpara><simpara>
            This document is now updated for version 1.67 of SqlFile, but I
            expect it to accurately describe SqlTool for some number of
            versions past 1.67.
            (SqlFile is the Java class where most of the SqlTool functionality
            is implemented.  The SqlTool startup banner shows the SqlFile
            version number).
        </simpara>
    </section>

    <section>
        <title>The Bare Minimum You Need to Know to Run SqlTool</title>
        <titleabbrev>The Bare Minimum</titleabbrev>
        <simpara>
            If you want to use SqlTool, then you either have an SQL text file, 
            or you want to interactively type in SQL commands.
            If neither case applies to you, then you are looking at the wrong 
            program.
        </simpara>
            <procedure>
                <title>To run SqlTool...</title>
                <step><simpara>
                    Copy the file <filename>sqltool.rc</filename> from the
                    directory <filename>src/org/hsqldb/sample</filename> of 
                    your HSQLDB distribution
                    to your home directory and
                    secure access to it if your home directory is accessible
                    to anybody else.
                    This file will work as-is for a Memory Only database
                    instance; or if your target is a HSQLDB Server 
                    running on your local computer with default settings
                    and the password for the "sa" account is blank
                    (the sa password is blank when new HSQLDB database 
                    instances are created).
                    Edit the file if you need to change the target Server URL, 
                    username, password, character set, or JDBD driver,
                    as documented in the 
                    <link linkend='auth-section' endterm='auth-title'/> section.
                </simpara></step><step><simpara>
                    Set up your CLASSPATH to include the classes
                    <classname>org.hsqldb.util.SqlTool</classname>,
                    <classname>org.hsqldb.util.SqlFile</classname>, and the 
                    JDBC driver that you want to use.  If you are using a 
                    HSQLDB database, this is most easily accomplished by
                    setting (and exporting) CLASSPATH to the path to 
                    <filename>hsqldb.jar </filename> (which lives in the 
                    <filename>lib</filename> subdirectory of the HSQLDB 
                    distribution).  (You can, of course, use a classpath 
                    argument to java instead of setting your CLASSPATH 
                    variable).
                </simpara></step><step><para>
                    Run 
                <informalexample><screen>
    java org.hsqldb.util.SqlTool --help</screen>
                </informalexample>
                    to see what command-line arguments are available.
                    Assuming that you set up your SqlTool configuration file 
                    at the default location and you want to use the HSQLDB 
                    JDBC driver, you will want to run either
                <informalexample><screen>
    java org.hsqldb.util.SqlTool mem</screen>
                </informalexample>
                    for interactive use, or
                <informalexample><screen>
    java org.hsqldb.util.SqlTool --noinput --sql 'SQL statement;' mem</screen>
                    </informalexample>
                    or
                    <informalexample><screen>
    java org.hsqldb.util.SqlTool mem filepath1.sql...</screen>
                    </informalexample>
                    where <literal>mem</literal> is an
                    <emphasis>urlid</emphasis>,
                    and the following arguments are paths to text SQL files.
                    For the filepaths, you can use whatever wildcards your 
                    operating system shell supports.
                    </para><simpara>
                    The <emphasis>urlid</emphasis> <literal>mem
                    </literal>in these commands is a key 
                    into your SqlTool configuration file, as explained in the 
                    <link linkend='auth-section' endterm='auth-title'/> section.
                    Since this is a Memory Only database, you can use SqlTool
                    with this urlid immediately with no database setup 
                    whatsoever (however, you can't persist any changes that 
                    you make to this database).
                    The sample sqltool.rc file also defines the urlid
                    "localhost-sa" for a local HSQLDB Server.
                </simpara></step>
            </procedure>
        <important><simpara>
            SqlTool does not <emphasis>commit</emphasis> DML changes by default.
            This leaves it to the user's disgression whether to commit or
            rollback their modifications.
            Remember to either run the command <literal>commit;</literal>
            before quitting SqlTool, or use the <literal>--autoCommit</literal>
            command-line switch.
        </simpara></important>
        <simpara>
            Note that the <literal>--sql</literal> switch runs the given
            commands <emphasis>in addition</emphasis> to standard input
            and/or specified SQL files.
            If you want to run only SQL command(s) which you give on the
            command-line, then use the <literal>--sql</literal> switch
            <emphasis>and</emphasis> the <literal>--noinput</literal> switch.
        </simpara> <simpara>
            If you put a file named <filename>auto.sql</filename> into your
            home directory, this file will be executed automatically every
            time you run SqlTool, unless you give the 
            <literal>--noAutoFile</literal> switch.
        </simpara> <para>
            To use a JDBC Driver other than the HSQLDB driver, you must put 
            the jar/zip file in the classpath (as explained in number 2 above), 
            and you must tell SqlTool what the JDBC driver class name is.
            The latter can be accomplished by either using the "--driver" 
            switch, or setting "driver" in your config file.
            The <link linkend='auth-section' endterm='auth-title'/> section.
            explains the second method.  Here's an example of the first method.
        <informalexample><screen>
    java org.hsqldb.util.SqlTool --driver oracle.jdbc.OracleDriver urlid</screen>
        </informalexample></para>
    </section>

    <section>
        <title>Using hsqlsqltool.jar</title>
        <simpara>
            If you do not need to connect to non-server HSQLDB URLs (i.e.,
            you do not need to connect to URLs of the form 
            <literal>jdbc:hsqldb:mem:*</literal> or
            <literal>jdbc:hsqldb:file:*</literal> or
            <literal>jdbc:hsqldb:res:*</literal>), then it will be easier
            to set up and run SqlTool by using
            <filename>hsqlsqltool.jar</filename> instead of 
            <filename>hsqldb.jar</filename>.
            If you plan to run a HSQLDB database, but not run a Server or
            WebServer, then just skip this section and use
            <filename>hsqldb.jar</filename>.
        </simpara><simpara>
            The HSQLDB distribution doesn't "come with" a pre-built 
            <filename>hsqlsqltool.jar</filename> file.
            However, if you will be connecting to HSQLDB Server(s)/WebServer(s),
            environment setup and use is simplified with 
            <filename>hsqlsqltool.jar</filename>.
            I recommend that you either download
            <ulink url='http://admc.com/dist/hsqlsqltool-1.7.2.jar'/>
            (by right-clicking and downloading if you're reading this with a
            web browser), or build the <emphasis>jarsqltool</emphasis> target, 
            as explained in the 
            <link linkend='building-appendix' endterm='building-title'/>
            appendix.
        </simpara>
        <para>
            To run SqlTool using a sqltool jar file, you don't need to set
            or specify any classpath, nor any class name.  Just run
            <example><title>Running SqlTool with a sqltool jar file</title>
                <screen>
    java -jar /path/to/hsqlsqltool.jar</screen>
            </example> where <literal>/path/to/hsqlsqltool.jar</literal> is
            the path to your hsqlsqltool.jar, whatever it may be named (for
            example, <filename>hsqlsqltool-1.7.2.jar</filename>).
            You can run any SqlTool command explained in this chapter by
            subsituting <literal>java -jar /path/to/hsqlsqltool.jar</literal>
            for <literal>java org.hsqldb.util.SqlTool</literal>.
        </para>
    </section>

    <section id='auth-section'>
        <title id='auth-title'>Authentication Setup</title>
        <simpara>
            Authentication setup is accomplished by creating a text SqlTool
            configuration file.
            In this section, when I say <emphasis>configuration</emphasis>
            or <emphasis>config</emphasis> file, I mean an SqlTool 
            configuration file (aka SqlTool RC file).
        </simpara><simpara>
            There is a sample <filename>sqltool.rc</filename> file in the
            directory <filename>src/org/hsqldb/sample</filename> of your
            HSQLDB distribution.
        </simpara><para>
            You can put this file anywhere you want to, and specify the 
            location to SqlTool by using the "--rcfile" argument.
            If there is no reason to not use the default location (and there 
            are situations where you would not want to), then use the default
            location and you won't have to give "--rcfile" arguments to 
            SQLTool.
            The default location is <emphasis>sqltool.rc</emphasis> in your 
            home directory.
            If you have any doubt about where that is, then just run SqlTool 
            with a phoney urlid and it will tell you where it expects the 
            configuration file to be.
        <informalexample><screen>
    java org.hsqldb.util.SqlTool x</screen>
        </informalexample></para><para>
            The config file consists of stanza(s) like this:
        <informalexample><screen>
    urlid web
    url jdbc:hsqldb:hsql://localhost
    username web
    password webspassword</screen>
        </informalexample></para><para>
            These four settings are required for every urlid.
            (There are optional settings also, which are described a couple 
            paragraphs down).
            You can have as many blank lines and comments like
        <informalexample><screen>
    # This comment</screen>
        </informalexample>
        </para><simpara>
            in the file as you like.
            The whole point is that the <emphasis>urlid</emphasis> that you 
            give in your SqlTool command must match a <emphasis>urlid
            </emphasis> in your configuration file.
        </simpara><important><simpara>
            Use whatever facilities are at  your disposal to protect your 
            configuration file.
        </simpara></important><simpara>
            It should be readable, both locally and remotely, only to users 
            who need to use the records in it to run SqlTool.
            On UNIX, this is easily accomplished by using <literal>chmod/chown
            </literal> commands and making sure that it is protected from 
            anonymous remote access (like via NFS, FTP or Samba).
        </simpara><simpara>
            You can also put the following optional settings into a urlid 
            stanza.  The setting will, of course, only apply to that urlid.
        </simpara>
        <variablelist>
            <varlistentry><term>charset</term><listitem><simpara>
                Sets encoding character set for input.
                See the <link linkend='charencoding-section'
                    endterm='charencoding-title'/> section of the
                <link linkend='nonint-section' endterm='nonint-title'/>
                section.
                You can, alternatively, set this for one SqlTool invocation 
                by setting the system property <property>sqltool.charset
                </property>.
                Defaults to <literal>US-ASCII</literal>.
            </simpara></listitem></varlistentry>
            <varlistentry><term>driver</term><listitem><simpara>
                Sets the JDBC driver class name.
                You can, alternatively, set this for one SqlTool invocation 
                by using the SqlTool switch <emphasis>--driver</emphasis>.
                Defaults to <emphasis>org.hsqldb.jdbcDriver</emphasis>.
            </simpara></listitem></varlistentry>
        </variablelist>
        <simpara>
            Property and SqlTool command-line switches override settings made 
            in the configuration file.
        </simpara>
    </section>

    <section id='int-section'>
        <title id='int-title'>Interactive</title>
        <para>
            You run SqlTool interactively by specifying no SQL filepaths on 
            the SqlTool command line.  Like this.
        <informalexample><screen>
    java org.hsqldb.util.SqlTool urlid</screen>
        </informalexample></para><simpara>
            If it starts up and connects to the database (as specified in your
            SqlTool configuration file as explained in the
            <link linkend='auth-section' endterm='auth-title'/> section),
            you will be shown a banner describing the 
            different command types that you can give, as well as commands to 
            list all of the specific commands available to you.
        </simpara><simpara>
            You exit your session by using the "\q" special command or ending 
            input (like with Ctrl-D or Ctrl-Z).
        </simpara>
        <variablelist><title>Command types</title>
            <varlistentry><term>SQL Statement</term><listitem><simpara>
                Any command that you enter which does not begin with "\", ":", 
                or "* " is an SQL Statement.
                The command is not terminated when you hit ENTER, like most 
                OS shells.
                You terminate SQL Statements with either ";" at the end of a 
                line, or with a blank line.
                In the former case, the SQL Statement will be executed against 
                the SQL database and the command will go into the command 
                buffer and command history for editing or viewing later on.
                In the latter case (you end an SQL Statement with a blank 
                line), the command will go to the buffer and history, but 
                will not be executed (but you can execute it later from the 
                buffer).
            </simpara><simpara>
                As a result of these termination rules, whenever you are 
                entering text that is not a Special Command, Buffer Command, 
                or PL Command, you are always 
                <emphasis>appending</emphasis> lines to an SQL Statement.
                (In the case of the first line, you will be appending to an
                empty SQL statement.  I.e. you will be starting a new SQL 
                Statement).
            </simpara></listitem></varlistentry>
            <varlistentry><term>Special Command</term><listitem><simpara>
                Run the command "\?" to list the Special Commands.
                All of the Special Commands begin with "\".
                You can't enter a Special Command if you have already typed 
                some line(s) of a SQL Statement, because the new line 
                containing the Special Command would just be interpreted as 
                another line in the SQL Statement.
                In this case, you just hit enter to clear the current SQL 
                Statement and send it off to the buffer (where you can ignore 
                it forever if you wish to).  I'll describe some of the most 
                useful Special Commands below.
            </simpara></listitem></varlistentry>
            <varlistentry><term>Buffer Command</term><listitem><simpara>
                Run the command ":?" to list the Special Commands.
                All of the Special Commands begin with ":".
                The text above about entering Special Commands if you have 
                already typed some line(s) of a SQL Statement applies equally 
                to Buffer Commands.
                Buffer commands operate upon the command "buffer", so that 
                you can edit and/or (re-)execute previously entered commands.
            </simpara></listitem></varlistentry>
            <varlistentry><term>PL Command</term><listitem><simpara>
                Procedural Langage commands.
                Run the command "* ?" to list the PL Commands.
                All of the PL Commands begin with "* ".
                The text above about entering Special Commands if you have 
                already typed some line(s) of a SQL Statement applies equally 
                to PL Commands.
                PL commands are for setting and using scripting variables
                and conditional and flow control statements like
                <literal>* if</literal> and <literal>* while</literal>.
                Using variables as command aliases (aka macros) can be a real
                convenience for nearly all users, so this feature will be
                discussed briefly in this section.
                More detailed explanation of PL variables and the other 
                PL features, with examples, are covered in the
                <link linkend='pl-section' endterm='pl-title'/> section.
            </simpara></listitem></varlistentry>
        </variablelist>
        <variablelist><title>Essential Special Commands</title>
            <varlistentry><term>\?</term><listitem><simpara>
                help
            </simpara></listitem></varlistentry>
            <varlistentry><term>\q</term><listitem><simpara>
                quit
            </simpara></listitem></varlistentry>
            <varlistentry><term>\dt</term><listitem><simpara>
                Lists available database tables.
                Works well for HSQLDB and for Oracle.
                Need user feedback about compatibility with other database 
                vendors.
            </simpara></listitem></varlistentry>
            <varlistentry><term>\d tablename</term><listitem><simpara>
                Lists names of all columns in the specified table.
            </simpara></listitem></varlistentry>
            <varlistentry><term>\s</term><listitem><simpara>
                Shows the command history.
                The command history will show a number (a negative number) 
                for each SQL Statement that has made it into the buffer so 
                fare (by either executing or entering a blank line).
                You can then use "\-" command (which is described next) to 
                retrieve commands from the history to work with.
                To list just the very last command, you would use the ":l" 
                buffer command to list the buffer contents, instead of this 
                command.
            </simpara></listitem></varlistentry>
            <varlistentry><term>\-[3]</term><listitem><simpara>
                Enter "\" followed by the command number from history, like
                "\-3".
                That command will be written to the buffer so that you can 
                execute it or edit it using buffer commands.
            </simpara></listitem></varlistentry>
        </variablelist>
        <simpara>
            This chapter documents only the <emphasis>essential</emphasis> 
            Special Commands, but n.b. that there are other useful Special 
            Commands which you can list by running <literal>\?</literal>.
            (You can, for example, list the available tables, list table
            columns, execute external commands, execute SQL from external 
            SQL files, and save your interactive SQL commands to files).
        </simpara>
        <simpara>
            Be aware that the <literal>\!</literal> Special Command does
            not work for external programs that read from standard input.
            You can not run graphical interactive programs, but not
            command-line interactive programs.
        </simpara>
        <variablelist><title>Buffer Commands</title>
            <varlistentry><term>:?</term><listitem><simpara>
                help
            </simpara></listitem></varlistentry>
            <varlistentry><term>:a</term><listitem><simpara>
                Enter append mode with the contents of the buffer as the 
                current SQL Statement.
                Things will be exacly like you typed in the command that is 
                in the buffer.
                Whatever line you type next will be appended to the SQL 
                Statement.
                You can, of course, execute the command by terminating a 
                line with ";", or send it back to the buffer by entering a 
                blank line.
            </simpara></listitem></varlistentry>
            <varlistentry><term>:l</term><listitem><simpara>
                List the current contents of the buffer.
            </simpara></listitem></varlistentry>
            <varlistentry><term>:;</term><listitem><simpara>
                Executes the current buffer against the database.
            </simpara></listitem></varlistentry>
            <varlistentry><term>:s/from string/to string/</term><listitem><para>
                Edits the current buffer.
                Don't use "/" if it occurs in either "from string" or "to 
                string".
                You can use any character that you want in place of "/", but 
                it must not occur in the from or to strings.
                Example
                <informalexample><screen>
    :s@from string@to string@</screen>
                </informalexample></para><simpara>
                All occurrences of the "from string" are substituted with "to 
                string".
                If the SQL Statement is multi-line, the substitution will 
                happen to all lines.
                (This easily be changed to accommondate editing only specific 
                lines of the buffer-- let me know if that would be useful to 
                you).
                </simpara><para>
                All occurrences of "$" in the "from string" and the "to string" 
                are treated as line breaks.
                For example, "from string" of
                "<literal>*$FROM mytable</literal>" would 
                actually look for occurrences of
                <informalexample><screen>
    "*
     FROM mytable"</screen>
                </informalexample></para><para>
                This is very useful, as it permits you to append to or prefix 
                to specific lines within a multi-line SQL Statement, like
                <informalexample><screen>
    :s/e)$/e) WHERE col1 is not null$/</screen>
                </informalexample></para><simpara>
                This command appends
                "<emphasis>WHERE col1 is not null</emphasis>" to the 
                line(s) which end with "e)".
                </simpara><para>
                The "to string" may be empty, in which case, occurrences of 
                the "from string" are just deleted.  For example
                <informalexample><screen>
    :s/this//</screen>
                </informalexample></para><simpara>
                would remove all occurrences of "this".
            </simpara></listitem></varlistentry>
        </variablelist>
        <variablelist><title>Essential PL Command</title>
            <varlistentry><term>* VARNAME = value</term><listitem><simpara>
                Set the value of a variable.
                If the variable doesn't exist yet, it will be created.
            </simpara><para>
                    If you set a variable to an SQL statement (without the
                    terminating ";") you can then use it as an alias like
                    <literal>*VARNAME</literal>, as shown in this example.
                <example id='alias-example'>
                    <title>Defining and using an alias (PL variable)</title>
                    <screen>
    * q = select count(*) from mytable
    *q;</screen>
                </example>
        </para></listitem></varlistentry>
        </variablelist>
        <simpara>
            See the <link linkend='pl-section' endterm='pl-title'/> section 
            below for information on using variables in other ways, and 
            information on the other PL commands and features.
        </simpara>
    </section>

    <section><title>Raw mode</title>
        <para>
            If for some reason you want SqlTool to process your commands as 
            if it were reading an SQL file, i.e., without giving a startup 
            banner or command prompts, and aborting upon failure by default, 
            then specify a SQL filepath of "-", like
        <informalexample><screen>
    java org.hsqldb.util.SqlTool urlid -</screen>
        </informalexample></para><simpara>
            You may want to do this if you are redirecting or tee-ing output 
            to a log file, and you don't want the user-interaction messages 
            ending up in the log file.
        </simpara>
    </section>

    <section id='nonint-section'>
        <title id='nonint-title'>Non-Interactive</title>
        <simpara>
            Read the <emphasis>Interactive</emphasis> section if you have not 
            already, 
            because much of what is in this section builds upon that.
            Even if your plans are to run SqlTool non-interactively, you 
            should really learn to run it interactively because it's such a 
            powerful debugging tool, and you can use it to prototype sql 
            scripts.
        </simpara>
        <important><simpara>
            If you're doing data updates, remember to issue a commit command
            or use the <literal>--autoCommit</literal> switch.
        </simpara></important>
        <section><title>Giving SQL on the Command Line</title>
            <para>
                If you just have a couple SQL commands to run, you can run them 
                directly from the comand-line or from a shell script without an 
                SQL file, like this.
            <informalexample><screen>
    java org.hsqldb.util.SqlTool --noinput --sql 'SQL statement;' urlid</screen>
            </informalexample></para><para>
                Since SqlTool executes SQL statements only when a statement 
                line is terminated with ";", you can only execute more than one 
                SQL statement this way if your OS shell has some mechanism to 
                pass linebreaks in arguments through to the target program.
                With any Bourne-compatible shell, you can include linebreaks in 
                the SQL statements like this.
            <informalexample><screen>
    java org.hsqldb.util.SqlTool --noinput --sql 'SQL statement;' urlid
        SQL statement number one;
        SQL statement
            number two;
        SQL statement three;
    ' urlid</screen>
            </informalexample></para><simpara>
                If you don't give the <literal>--noinput</literal> switch, then 
                after executing the given statements, an interactive session 
                will be started.
            </simpara><para>
                The <emphasis>--sql</emphasis> switch is very useful for 
                setting shell variables to the output of SQL Statements, like 
                this.
            <informalexample><programlisting>
    # A shell script
    USERCOUNT=`java org.hsqldb.util.SqlTool --noinput --sql 'select count(*) from usertbl;' urlid` || {
        # Handle the SqlTool error
    }
    echo "There are $USERCOUNT users registered in the database."
    [ "$USECOUNT" -gt 3 ] &amp;&amp; {   # If there are more than 3 users registered
        # Some conditional shell scripting</programlisting></informalexample>
            </para>
        </section>
        <section><title>SQL Files</title>
            <simpara>
                Just give paths to sql text file(s) on the command line after 
                the <emphasis>urlid</emphasis>.
            </simpara><para>
                Often, you will want to redirect output to a file, like
            <informalexample><screen>
    java org.hsqldb.util.SqlTool urlid filepath1.sql... > /tmp/log.sql 2>&amp;1</screen>
            </informalexample></para><simpara>
                (Skip the "2>&amp;1" if you're on Windows).
            </simpara><simpara>
                You can also execute SQL files from an interacrtive session with
                the "\i"' Special Command.
            </simpara><simpara>
                You can use the following SQL file,
                <filename>sample.sql</filename>, which resides in the
                <filename>src/org/hsqldb/sample</filename> directory of your
                HSQLDB distribution.
                It contains SQL as well as Special Commands making good
                use of most of the Special Commands documented below.
            </simpara>
            <programlisting>&sample.sql-cdata;</programlisting>
            <para>
                You can execute this SQL file with a Memory Only database with 
                a command like
            <informalexample><programlisting>
    java org.hsqldb.util.SqlTool --sql "create user 'tomcat' password 'x';" mem path/to/hsqldb/src/org/hsqldb/sample/sample.sql</programlisting>
            </informalexample>
            </para><simpara>
                (The <literal>--sql "create..."</literal> arguments create an
                account which the script uses).
            </simpara>
        </section>
        <section>
            <title>Optimally Compatible SQL Files</title>
            <simpara>
                If you want your SQL scripts optimally compatible among other
                SQL tools, then don't use any Special or PL Commands
                SqlTool has default behavior which I think is far superior to 
                the other SQL tools, but you will have to disable these 
                defaults in order to be behavior-compatible.
            </simpara><para>
                These switches provide compatibilty at the cost of poor 
                control and error detection.
                <itemizedlist>
                    <listitem><para>--noAutoFile</para></listitem>
                    <listitem><para>--autoCommit</para></listitem>
                    <listitem><para>--continueOnErr</para></listitem>
                </itemizedlist>
            </para><simpara>
                You don't have to worry about accidental expansion of 
                PL variables, since SqlTool will never expand PL variables
                if you don't set any variables on the command line, or give 
                any "* " PL commands.
                (And you could not have "* " commands in a compatible SQL 
                file).
            </simpara>
        </section>
        <section><title>Comments</title>
            <simpara>
                SQL comments of the form <literal>/*...*/</literal> must begin
                where a (SQL/Special/Buffer/PL) Command could begin, and they
                end with the very first "/*" (regardless of quotes, nesting,
                etc.
            </simpara>
            <example><title>Valid comment example</title><programlisting>
    SELECT count(*) FROM atable;
    /* Lots of
     comments interspersed among
     several lines */   SELECT count(*)
    FROM btable;</programlisting>
            </example>
            <simpara>
                Notice that a command can start immediate after the comment
                ends.
            </simpara>
            <example><title>Valid comment example</title><programlisting>
    SELECT count(*) FROM
    /* atable */
    btable;</programlisting>
            </example>
            <simpara>
                This comment is invalid because you could not start another
                command at the comment location (because it is within an SQL
                Statement).
            </simpara>
            <simpara>
                You can try using <literal>/*...*/</literal> in other locations,
                and <literal>--</literal> style SQL comments, but SqlTool will
                not treat them as comments.
                If they occur within an SQL Statment, SqlTool will pass them to
                the database engine, and the DB engine will determine whether
                they are parsed as comments.
            </simpara>
        </section>
        <section>
            <title>Special Commands and Buffer Commands in SQL Files</title>
            <simpara>
                Don't use Buffer Commands in your sql files, because they won't 
                work.
                Buffer Commands are for interactive use only.
            </simpara><simpara>
                Most Special Commands won't work in sql files, but the 
                following not only work, but were designed for use in sql files.
            </simpara>
            <variablelist>
                <varlistentry><term>\p [text to print]</term><listitem><simpara>
                    Print the given string to stdout
                </simpara></listitem></varlistentry>
                <varlistentry><term>\i /path/to/file.sql</term><listitem><simpara>
                    Include another SQL file at this location.
                    You can use this to nest SQL files.
                    For database installation scripts I often have a master
                    SQL file which includes all of the other SQL files in the
                    correct sequence.
                </simpara></listitem></varlistentry>
                <varlistentry><term>\H</term><listitem><para>
                    Toggle HTML output mode.
                    If you redirect output to a file, this can make query 
                    output much easier to view.
                    For example,
                    <informalexample><screen>
    java org.hsqldb.util.SqlTool urlid filepath1.sql... > /tmp/log.html 2>&amp;1</screen>
                    </informalexample>
                </para></listitem></varlistentry>
                <varlistentry><term>\a [true|false]</term><listitem><simpara>
                    This turns on and off JDBC transaction autocommits.
                    Auto-commit defaults to false, but you can change that
                    behavior by using the <literal>--autoCommit</literal>
                    command-line switch.
                </simpara></listitem></varlistentry>
                <varlistentry><term>\* [true|false]</term><listitem><simpara>
                    A "true" setting tells SqlTool to continue when errors are 
                    encountered.
                    The default for interactive use is to continue upon error, 
                    but the default for non-interactive use is to abort upon 
                    error.
                    You can override that behavior by using the
                    <literal>--continueOnErr</literal> or the
                    <literal>--abortOnErr</literal> command-line switch.
                    </simpara><simpara>
                    With database setup scripts, I usually find it convenient 
                    to set "true" before deleting tables (so that things will 
                    continue if the tables aren't there), then set it back to 
                    false so that real errors are caught.
                </simpara></listitem></varlistentry>
            </variablelist>
        </section>
        <section><title>Getting Interactive Functionality with SQL Files</title>
            <para>
                Some script developers may run into cases where they want to 
                run with sql files but they want SqlTool's interactive behavior.
                For example, they may want to do command recall in the sql file,
                or they may want to log SqlTool's command-line prompts (which 
                are not printed in non-interactive mode).
                In this case, do not give the sql file(s) as an argument to 
                SqlTool, but pipe them in instead, like
            <informalexample><screen>
    java org.hsqldb.util.SqlTool urlid &lt; filepath1.sql &gt; /tmp/log.html 2&gt;&amp;1</screen>
            </informalexample>
                or
            <informalexample><screen>
    cat filepath1.sql... |
    java org.hsqldb.util.SqlTool urlid &gt; /tmp/log.html 2&gt;&amp;1</screen>
            </informalexample>
            </para>
        </section>
        <section id='charencoding-section'><title id='charencoding-title'>
                Character Encoding</title>
            <para>
                SqlTool defaults to the US-ASCII character set (for reading).
                You can use another character set by setting the system 
                property <property>sqltool.charset</property>, like
            <informalexample><screen>
    java -Dsqltool.charset=UTF-8 org.hsqldb.util.SqlTool urlid filepath1.sql...</screen>
            </informalexample></para><simpara>
                You can also set this per urlid in the SqlTool configuration 
                file.
                See the <link linkend='auth-section' endterm='auth-title'/>
                section about that.
            </simpara>
        </section>
    </section>

    <section id='pl-section'>
        <title id='pl-title'>Procedural Language</title>
        <subtitle>Aka PL</subtitle>
        <simpara>
            Most importantly, run SqlTool interactively and give the "* ?"
            command to see what PL commands are available to you.
        </simpara> <simpara>
            As noted elsewhere, PL variables will only be expanded after you
            run a PL command (or set variable(s) from the command-line).
        </simpara>
        <section>
            <title>Variables</title>
            <itemizedlist>
                <listitem><simpara>
                    Use the <literal>* list</literal> command to list some or
                    all variables and their values.
                </simpara></listitem> <listitem><simpara>
                    You can set variables using the
                    <literal>* VARNAME = value</literal> command.
                </simpara></listitem> <listitem><simpara>
                    You can also set variables using the 
                    <literal>--setvar</literal> command-line switch.
                    I give a very useful example of this below.
                </simpara></listitem> <listitem><simpara>
                    Variables are always expanded in SQL, Special, and PL
                    commands if they are written like
                    <literal>*{VARNAME}</literal>
                    Your SQL scripts can give good feedback by echoing the
                    value of variables with the "\p" special command.
                </simpara></listitem> <listitem><simpara>
                    Variables written like <literal>*VARNAME</literal> are
                    expanded if they <emphasis>begin</emphasis> an SQL
                    Statement.
                    (They must also be followed by whitespace or terminate the
                    Statement).
                    I usually refer to this use of PL variables as
                    <emphasis>aliases</emphasis>.
                    If the value of a variable is an entire SQL command, you
                    generally do not want to include the terminating ";" in
                    the value.
                    There is an example of this 
                    <link linkend='alias-example'>above</link>.
                </simpara></listitem> <listitem><simpara>
                    Variables are normally written like 
                    <literal>*VARNAME</literal> in logical expressions to
                    prevent them from being evaluated too early.
                    See below about logical expressions.
                </simpara></listitem> <listitem><simpara>
                    You can continuosly modify variable values, like
                    <literal>@ x = @{x}/@{addeddir}</literal>.
                    This is useful in conjunctionj with conditional flow
                    control.
                </simpara></listitem>
            </itemizedlist>
            <simpara>
                Here is a short SQL file that gives the specified user write
                permissions on some application tables.
            </simpara>
            <example><title>Sample SQL file using PL</title>
                <programlisting>
    /*
       grantwrite.sql

       Run SqlTool like this:
           java org.hsqldb.util.SqlTool -setvar USER=debbie grantwrite.sql
     */
    GRANT all ON book TO *{USER};
    GRANT all ON category TO *{USER};</programlisting>
            </example>
            <simpara>
                Note that this script will work for any (existing) user just
                by supplying a different user name on the command-line.
                I.e., no need to modify the tested and proven script.
                There is no need for a <literal>commit</literal> statement
                in this SQL file since no DML is done.
                If the script is accidentally running without setting the
                USER variable, SqlTool will give a very clear notificaton of
                that.
            </simpara>
        </section>
        <section>
            <title>Logical Expressions</title>
            <simpara>
                Logical expressions occur only inside of parentheses and only
                in PL statements.
                For example, <literal>if (*var1 > astring)</literal> and
                <literal>while (*checkvar)</literal>.
            </simpara> <simpara>
                The <literal>*VARNAME</literal> occurrences are expanded late
                so that the result of <literal>while *LOOPVAR</literal> will
                change depending on the current value of LOOPVAR.
            </simpara> <simpara>
                This does not work with quoting of any type, not with values
                containing white space.
                If you're using variables in logical expressions, stick to
                simple tokens with normal characters.
            </simpara>
            <variablelist>
                <title>Logical Operators</title>
                <varlistentry><term>TOKEN</term><listitem><simpara>
                    The token may be a literal, a <literal>*{VARNAME}</literal>
                    which is expanded early, or a *VARNAME which is expanded 
                    late.
                    (You usually do not want to use 
                    <literal>*{VARNAME}</literal> in logical expressions).
                    False if the token is not set, empty, or "0".
                    True otherwise.
                </simpara></listitem></varlistentry>
                <varlistentry><term>TOKEN1 == TOKEN2</term><listitem><simpara>
                    True if the two tokens are equivalent "strings".
                </simpara></listitem></varlistentry>
                <varlistentry><term>TOKEN1 &lt;&gt; TOKEN2</term><listitem><simpara>
                    Ditto.
                </simpara></listitem></varlistentry>
                <varlistentry><term>TOKEN1 &gt;&lt; TOKEN2</term><listitem><simpara>
                    Ditto.
                </simpara></listitem></varlistentry>
                <varlistentry><term>TOKEN1 &gt; TOKEN2</term><listitem><simpara>
                    True if the TOKEN1 string is longer than TOKEN2 or is
                    the same length but is greater according to a string sort.
                </simpara></listitem></varlistentry>
                <varlistentry><term>TOKEN1 &lt; TOKEN2</term><listitem><simpara>
                    Similarly to TOKEN1 &gt; TOKEN2.
                </simpara></listitem></varlistentry>
            </variablelist>
        </section>
        <section>
            <title>Flow Control</title>
            <simpara>
                Flow control works by conditionally executing blocks of 
                Commands according to conditions specified by logical 
                expressions.
            </simpara> <simpara>
                The conditionally executed blocks are called 
                <emphasis>PL Blocks</emphasis>.
                These PL Blocks always occur between a PL flow control 
                statement (like <literal>* foreach, *while, * if</literal>)
                and a <literal>* end</literal> PL Command.
            </simpara> <simpara>
                The values of control variables for foreach and while PL
                blocks will change as expected.
            </simpara>
        </section>
    </section>
</chapter>
